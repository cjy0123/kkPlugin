package com.kk.plugin.itemWay;

import com.goide.psi.GoConstDeclaration;
import com.goide.psi.GoConstSpec;
import com.goide.psi.GoFile;
import com.intellij.openapi.actionSystem.ActionPlaces;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import com.kk.plugin.util.PsiFileUtil;
import com.kk.plugin.util.ToolUtil;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class itemWay extends AnAction {

    private static List<String> sortList = new ArrayList<>();

    @Override
    public void actionPerformed(AnActionEvent e) {
        Project project = e.getProject();
        if (project == null) return;

        VirtualFile file = e.getDataContext().getData(CommonDataKeys.VIRTUAL_FILE);
        // 解析 PsiFile
        PsiFile psiFile = null;
        if (file != null) {
            psiFile = PsiManager.getInstance(project).findFile(file);
        }
        if (!(psiFile instanceof GoFile goFile)) {
            return;
        }

        // 读取常量
        Map<String, String> constants = extractConstantsWithComments(goFile);
        if (constants == null) {
            return;
        }
        VirtualFile commVirFile = ToolUtil.findTargetFile(file.getParent(), "comm.go", 2);
        if (commVirFile == null) {
            return;
        }
        try {
            String commFileContent = PsiFileUtil.readGoFileContent(commVirFile);
            String markerStart = "// BEGIN AUTOGENERATED CODE";
            String markerEnd = "// END AUTOGENERATED CODE";
            String newCode = makeCode(constants);
            String updatedContent = generateAndReplaceCode(commFileContent, newCode, markerStart, markerEnd);
            if (updatedContent.isEmpty()) {
                return;
            }
            ApplicationManager.getApplication().runWriteAction(() -> {
                PsiFileUtil.write(commVirFile, updatedContent);
            });
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void update(AnActionEvent e) {
        Project project = e.getProject();
        if (project == null) {
            return;
        }
        if (!ActionPlaces.EDITOR_POPUP.equals(e.getPlace())) {//只有在点击右键时才做过滤
            return;
        }
        VirtualFile file = e.getDataContext().getData(CommonDataKeys.VIRTUAL_FILE);
        if (file == null || !file.getName().equals("module_open.go")) {
            e.getPresentation().setEnabledAndVisible(false);
        }
    }

    public static Map<String, String> extractConstantsWithComments(GoFile goFile) {
        Map<String, String> constants = new HashMap<>();
        sortList = new ArrayList<>();
        for (GoConstDeclaration goConstDeclaration : PsiTreeUtil.findChildrenOfType(goFile, GoConstDeclaration.class)) {
            for (GoConstSpec goConstSpec : goConstDeclaration.getConstSpecList()) {
                String constName = goConstSpec.getConstDefinitionList().get(0).getText();
                if (constName.startsWith("Open")) {
                    String comment;
                    if (goConstSpec.getNextSibling() != null) {
                        comment = getCommentForElement(goConstSpec);
                    } else {
                        comment = getCommentForElement(goConstDeclaration);
                    }

                    if (comment.isEmpty()) {
                        Messages.showMessageDialog(constName + "没有添加备注", "代码生成错误", null);
                        return null;
                    }
                    constants.put(constName, comment);
                    sortList.add(constName);
                }
            }
        }
        return constants;
    }

    private static String getCommentForElement(PsiElement element) {
        PsiElement nextComment = element.getNextSibling();
        while ((nextComment instanceof PsiWhiteSpace)) {
            nextComment = nextComment.getNextSibling();
        }
        if (!(nextComment instanceof PsiComment)) {
            return "";
        }
        return nextComment.getText().replace("//", "").trim();
    }


    public String makeCode(Map<String, String> constants) {
        StringBuilder builder = new StringBuilder("\n");
        for (String constant : sortList) {
            String comment = constants.get(constant);
            String name = constant.substring(4); // 去掉 "Open" 前缀
            builder.append("func New").append(name).append("Get(val int32, name string) GetWay {\n")
                    .append("    const mdType = constant.").append(constant).append("\n")
                    .append("    return GetWay(GetWayStruct{\n")
                    .append("        WayStruct: NewWay(MakeGetWay(mdType, val), name, mdType, \"").append(comment).append("\"),\n")
                    .append("    }.Id)\n")
                    .append("}\n\n");

            builder.append("func New").append(name).append("Use(val int32, name string) UseWay {\n")
                    .append("    const mdType = constant.").append(constant).append("\n")
                    .append("    return UseWay(UseWayStruct{\n")
                    .append("        WayStruct: NewWay(MakeUseWay(mdType, val), name, mdType, \"").append(comment).append("\"),\n")
                    .append("    }.Id)\n")
                    .append("}\n\n");
        }
        builder.append("\n");
        return builder.toString();
    }


    public String generateAndReplaceCode(String content, String newCode, String markerStart, String markerEnd) {
        // 在 content 中查找 markerStart 和 markerEnd 的位置
        int startIndex = content.indexOf(markerStart);
        int endIndex = content.indexOf(markerEnd);

        // 如果找到了 markerStart 和 markerEnd
        if (startIndex != -1 && endIndex != -1) {
            // 生成替换后的代码
            return content.substring(0, startIndex + markerStart.length()) + newCode + content.substring(endIndex);
        } else {
            // 如果没有找到 markerStart 和 markerEnd，则直接返回原始内容
            Messages.showMessageDialog("找不到代码标记位置，请检查comm.go文件","错误",null);
            return "";
        }
    }
}
